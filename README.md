# Numerolog Bot MVP (каркас)

Каркас проекта для Telegram-бота “ИИ-аналитик личных данных”. Стек: **Python + FastAPI + aiogram**.

## Структура проекта

```
.github/workflows     # GitHub Actions (автодеплой)
  deploy.yml          # workflow автодеплоя
alembic/              # миграции Alembic
app/
  api/                # HTTP API (FastAPI)
  bot/                # Telegram-бот (aiogram)
    handlers/         # обработчики сценариев и FSM ввода профиля
      screen_manager.py # менеджер экранов (хранит message_ids и очищает чат)
    questionnaire/    # конфиг и вспомогательные модули анкеты
  core/               # конфигурация и общие утилиты
    llm_router.py     # LLM-маршрутизатор (Gemini -> ChatGPT)
    pdf_service.py    # генерация PDF и слой хранения (bucket/local)
    report_safety.py  # фильтрация запрещённых слов, гарантий и красных зон
    report_service.py # сервис генерации отчёта и каркаса T0-T3
  db/                 # модели и подключение к БД
  payments/           # платёжные провайдеры и проверки webhook
scripts/              # вспомогательные скрипты
  deploy.sh           # серверный деплой-скрипт (используется GitHub Actions)
  test.sh             # локальные проверки
  fast_checks.py      # быстрые сценарные проверки без внешних зависимостей
AUTODEPLOY_INSTRUCTIONS.md # пошаговая инструкция по автодеплою
.env.prompts.example # пример файла с системными промптами по тарифам
TZ.md                 # техническое задание (ТЗ)
```

## Предварительные требования

- Python 3.10+
- PostgreSQL (для работы с базой данных)

## Локальный запуск

1. Создайте виртуальное окружение и установите зависимости:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

2. Скопируйте файл окружения и заполните значения:

```bash
cp .env.example .env
```

3. (Опционально) Скопируйте пример системных промптов и отредактируйте под свои формулировки:

```bash
cp .env.prompts.example .env.prompts
```

4. Настройте ключевые параметры в `.env` (минимум для запуска):

```
BOT_TOKEN=...
DATABASE_URL=postgresql://user:password@localhost:5432/numerolog_bot
# Отключение глобального меню в inline-клавиатуре:
GLOBAL_MENU_ENABLED=false
# Отключение фильтрации результата (post-фильтр отчёта):
REPORT_SAFETY_ENABLED=true
# Отключение проверки оплаты (тестовый режим):
PAYMENT_ENABLED=true
# Искусственная задержка перед выдачей отчёта (секунды, с анимацией и таймером):
REPORT_DELAY_SECONDS=0
```

5. Выполните миграции:

```bash
alembic upgrade head
```

6. Запустите API:

```bash
uvicorn app.main:app --reload
```

7. Запустите бота в режиме polling:

```bash
python -m app.bot.polling
```

## Использование бота (основной поток)

1. Откройте бота и выберите тариф на экране **Тарифы**.
2. Для T1–T3 подтвердите оплату, затем заполните экран **Мои данные** (дата, время и место рождения принимаются в любом формате).
3. Для T2/T3 пройдите расширенную анкету — ответы принимаются в произвольном формате без форматирования и валидации, сохраняются после каждого шага и доступны для продолжения.
4. После завершения анкеты (или сразу после профиля для T0/T1) получите отчёт — перед выдачей может применяться искусственная задержка с анимацией и таймером (настраивается через `REPORT_DELAY_SECONDS`), затем PDF формируется автоматически и отправляется в чат, а кнопка «Выгрузить PDF» остаётся для повторной загрузки.

## Локальная отладка

### Запуск через tmux (только для локальной отладки, **не для продакшена**)

1. Установите tmux и создайте сессию:

```bash
sudo apt install tmux
tmux new -s numerolog_bot
```

2. Запустите API в первой панели:

```bash
source .venv/bin/activate
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

3. Разделите окно на две панели и запустите бота:

```bash
tmux split-window -h
source .venv/bin/activate
python -m app.bot.polling
```

4. Выйдите из tmux без остановки процессов:

```bash
tmux detach
```

5. Чтобы вернуться в сессию:

```bash
tmux attach -t numerolog_bot
```

> Для продакшена используйте **только** `systemd`, чтобы гарантировать один экземпляр процесса и автозапуск при перезагрузке сервера. Ручные запуски и `tmux` в продакшене не используйте.

## Проверки

Быстрые сценарные проверки (без внешних зависимостей по умолчанию):

```bash
./scripts/test.sh
```

Сценарии включают:
- T0 cooldown,
- оплата → генерация,
- fallback LLM,
- webhook-валидация провайдеров,
- повторная выдача PDF.

## Контентная безопасность

После генерации отчёта применяется post-фильтр: запрещённая лексика, паттерны гарантий/предсказаний и «красные зоны».  
Если обнаружены нарушения, выполняется регенерация (до 2 раз).  
Если текст по-прежнему содержит «красные зоны», бот возвращает безопасный отказ.  
Если нарушения остаются без красных зон, бот выдаёт резервный безопасный отчёт.  
Флаги фильтрации сохраняются в `reports.safety_flags`.
При необходимости можно отключить post-фильтр через `REPORT_SAFETY_ENABLED=false` (текст отправляется без проверки).  

## LLM fallback

- Основной провайдер — Gemini, fallback — OpenAI.
- Если Gemini возвращает ошибки авторизации/лимита или модель не найдена (например, 400/404), бот автоматически переключается на OpenAI.
- Для Gemini системные инструкции передаются через `systemInstruction`, а данные — отдельным блоком `facts-pack`, чтобы избежать ошибок валидации запроса.
- При 429 применяется увеличенный backoff (с учётом `Retry-After`, если он задан), чтобы снизить риск повторных rate-limit.

## Автодеплой

Подробные пошаговые инструкции по настройке автодеплоя описаны в `AUTODEPLOY_INSTRUCTIONS.md`.

## Системные промпты по тарифам

Системные промпты для LLM можно управлять вручную через файл `.env.prompts` в корне проекта.  
Формат — переменные `PROMPT_T0`, `PROMPT_T1`, `PROMPT_T2`, `PROMPT_T3`. Если файл отсутствует или переменные не заданы, используются встроенные безопасные значения.  
Пример заполнения находится в `.env.prompts.example`.

## Запуск через systemd

`systemd` обеспечивает запуск **ровно одного экземпляра** сервиса (API и бота) и автоматический рестарт при сбоях.

### Пример unit-файла для API (`/etc/systemd/system/numerolog-api.service`)

```ini
[Unit]
Description=Numerolog Bot API (FastAPI)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/uvicorn app.main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Пример unit-файла для бота (`/etc/systemd/system/numerolog-bot.service`)

```ini
[Unit]
Description=Numerolog Bot (Telegram, aiogram)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/python -m app.bot.polling
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Управление сервисами

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog-api.service
sudo systemctl enable --now numerolog-bot.service
```

**Стандартный способ перезапуска после деплоя (гарантирует одиночные процессы и предотвращает размножение инстансов):**

```bash
sudo systemctl restart numerolog-api.service
sudo systemctl restart numerolog-bot.service
```

### Пример target для общего управления

Если хотите управлять API и ботом одной командой, создайте target:

```ini
# /etc/systemd/system/numerolog.target
[Unit]
Description=Numerolog Bot (API + Bot)
Requires=numerolog-api.service numerolog-bot.service
After=network.target
```

Команды:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog.target
sudo systemctl restart numerolog.target
```

## Использование

- Откройте чат с ботом в Telegram и нажмите **Start** — на стартовом экране доступны кнопки **«Тарифы»**, **«Оферта»**, **«Обратная связь»**.
- После перехода на экран тарифов показываются четыре CTA-кнопки в одном столбце: «Т0 - Твоё новое начало (бесплатно)», «Т1 - В чём твоя сила?», «Т2 - Где твои деньги?», «Т3 - Твой путь к себе!» (глобальное меню на этом экране скрыто).
- Для T0 бот сразу запускает пошаговый ввод профиля (имя, дата, время, место рождения), а для T1–T3 мастер ввода стартует после подтверждения оплаты.
- В тарифах T2/T3 после профиля запускается лайтовая анкета из `app/bot/questionnaire/questionnaire_v1.json` с сохранением прогресса и поддержкой типов text/choice/scale; ответы принимаются в произвольном формате без форматирования и валидации.
- Управляйте сценариями через inline-клавиатуру: тарифы, оферта, обратная связь (в большинстве экранов).
- Все тексты экранов начинаются с технического идентификатора экрана (например, `S1:`), чтобы быстрее сверять сценарии с кодом.
- Экран “Мои данные” работает в режиме просмотра и показывает сохранённые поля профиля.
- Если тариф ещё не выбран, кнопка “Мои данные” возвращает к выбору тарифа, чтобы соблюсти порядок экранов.
- Для платных тарифов без подтверждённой оплаты экран “Мои данные” показывает кнопку перехода к оплате и блокирует старт мастера ввода.
- На экране “Мои данные” всегда доступна кнопка “Назад” для возврата к тарифам.
- Если профиль уже заполнен, на экране “Мои данные” доступна кнопка “Удалить мои данные” — она открывает подтверждение с кнопками «Да/Отмена» и очищает все данные пользователя, сохраняя учётную запись.
- Экран оплаты открывается только после перехода через оферту (S2 → S3), чтобы зафиксировать согласие с условиями.
- Для заполнения/изменения профиля нажмите “Заполнить данные” или “Перезаполнить” и
  последовательно введите имя, дату рождения, время рождения и место рождения в любом формате.
- После выбора тарифа “Т0 - Твоё новое начало (бесплатно)” показывается отдельный экран с описанием превью и
  кнопками “Старт”, “Назад” и “Обратная связь” (без пунктов “Оферта” и “Мои данные” на этом экране).
- Если лимит T0 исчерпан, экран уведомления (S9) показывает одну кнопку “Назад” и возвращает к тарифам.
- Глобальное меню (Тарифы, Мои данные, Оферта, Обратная связь) доступно на большинстве ключевых экранов
  (кроме экрана тарифов после «Далее...» и экрана превью T0).
- Для платных тарифов создаётся заказ в БД, оплата подтверждается перед генерацией отчёта.
- Для тарифа Т0 действует лимит 1 раз в месяц (настраивается через `FREE_T0_COOLDOWN_HOURS`).
- Для тарифов T2/T3 после профиля запускается анкета (конфиг `app/bot/questionnaire/questionnaire_v1.json`) и доступна только после подтверждённой оплаты; ответы принимаются в произвольном формате без форматирования и валидации.
- Прогресс анкеты сохраняется в БД и может быть продолжен с того же шага.
- Состояние экранов сохраняется в таблице `screen_states`, поэтому при рестарте процесса выбор тарифа
  и данные экранов восстанавливаются из БД.
- После успешной генерации отчёт сохраняется в таблице `reports`, а при повторном просмотре экрана S7 текст подтягивается из БД.
- На экране S7 доступна кнопка «Назад», возвращающая к тарифам.
- После генерации отчёта выполняется фильтрация: запрещённые слова/паттерны “гарантий/предсказаний” вызывают регенерацию (до 2 попыток), при «красных зонах» выдаётся безопасный отказ, а при остальных нарушениях — резервный безопасный отчёт.
- Информация о фильтрации записывается в `reports.safety_flags`.
- Запросы к LLM идут в Gemini как к основному провайдеру, при ошибках 401/403/429/5xx/timeout выполняется fallback на ChatGPT с ограниченными ретраями (до 2 на Gemini и до 1 на ChatGPT). При наличии нескольких API-ключей каждого провайдера выполняется автоматический перебор ключей до fallback.
- PDF формируется автоматически сразу после генерации отчёта и сохраняется в `reports.pdf_storage_key`. Кнопка “Выгрузить PDF” остаётся для повторных скачиваний.
- Telegram ID пользователя хранится в `users.telegram_user_id` и `screen_states.telegram_user_id` как `BIGINT`, чтобы корректно обрабатывать большие значения.

## Обратная связь (экран S8)

В экране “Обратная связь” пользователь пишет текстовое сообщение и нажимает “Отправить”.
Поведение зависит от режима в `.env`:

- `FEEDBACK_MODE=native` — бот отправляет сообщение в `FEEDBACK_GROUP_CHAT_ID` через Bot API и
  сохраняет результат в `feedback_messages` со статусом `sent`/`failed`.
- `FEEDBACK_MODE=livegram` — бот не отправляет сообщение напрямую, а просит перейти в группу
  по `FEEDBACK_GROUP_URL` (fallback-сценарий). Нажатие «Отправить» фиксирует попытку
  как `failed` в `feedback_messages`, чтобы видеть неуспешные отправки.
- Если `FEEDBACK_GROUP_CHAT_ID` отсутствует в режиме `native`, бот не падает и сообщает,
  что настройка не задана; попытка также логируется со статусом `failed`.

## PDF-хранение

- По умолчанию PDF сохраняются локально в каталог `storage/pdfs` (или другой путь, заданный через `PDF_STORAGE_KEY`).
- Если указать `PDF_STORAGE_BUCKET`, файлы сохраняются в S3-совместимом бакете. `PDF_STORAGE_KEY` используется как префикс ключа.
- Для bucket-хранилища задайте переменные `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION` и при необходимости `AWS_ENDPOINT_URL`.
- Для корректной кириллицы задайте `PDF_FONT_PATH` (например, `/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf`): при генерации PDF используется этот пользовательский шрифт, а при отсутствии файла — встроенный резервный.
- PDF генерируется автоматически сразу после формирования отчёта, а повторные скачивания используют сохранённый `reports.pdf_storage_key` (если доступно хранилище). Кнопка «Выгрузить PDF» остаётся для ручной повторной выдачи.
- Если `PDF_STORAGE_BUCKET` не задан или S3-хранилище не удалось инициализировать (например, отсутствует `boto3`), сервис автоматически использует локальный каталог и всё равно сохраняет `reports.pdf_storage_key`.

## Анкета T2/T3

- Конфигурация анкеты хранится в `app/bot/questionnaire/questionnaire_v1.json`.
- Поддерживаются типы вопросов: `text`, `choice`, `scale`, обязательность и переходы по логике; ответы принимаются в произвольном формате без форматирования и валидации.
- В текущей версии анкеты все вопросы настроены как свободный ввод без обязательного формата.
- Ответы сохраняются по мере ввода и используются при формировании facts-pack для LLM.
- Webhook оплаты принимает запросы на `/webhooks/payments` и проверяет подпись провайдера.
- Если основной провайдер недоступен или не сконфигурирован, бот пробует сформировать ссылку через CloudPayments и обновляет `orders.provider` для корректной проверки статуса.
- При отсутствии параметра `provider` в webhook-URL API пытается валидировать подпись сначала основным провайдером, затем fallback-провайдером.
- Кнопка “Я оплатил(а)” запрашивает статус у платёжного провайдера и переводит на ввод данных
  только после подтверждения оплаты.
- Генерация отчётов использует LLM-маршрутизатор: Gemini (основной) с 1–2 ретраями на 5xx/timeout,
  fallback на ChatGPT при ошибках 401/403/429/5xx/timeout (у ChatGPT — 1 retry на transient).
  Если указаны несколько ключей для провайдера, они перебираются автоматически при ошибках/недоступности.
- Перед отправкой в LLM формируется facts-pack (JSON) с исходными полями профиля и анкеты
  без нормализации и валидации: пользовательские строки передаются как есть.
- Если недоступны оба провайдера, бот показывает экран “Сервис временно недоступен”.
- Если ключи LLM не настроены (нет `GEMINI_API_KEY`/`GEMINI_API_KEYS` и `OPENAI_API_KEY`/`OPENAI_API_KEYS`),
  бот сразу показывает экран “Сервис временно недоступен” и не запускает генерацию.

## Логика тарифов и оплат

- Т0 можно запросить только после окончания cooldown: бот сверяет `last_t0_at` в таблице `free_limits`.
- Для T1–T3 бот создаёт запись в `orders` со статусом `created` и показывает экран оплаты.
- Генерация отчёта доступна **только** после статуса `paid`.
- Для платных тарифов действует правило «одна оплата — один отчёт»: если отчёт уже создан для заказа, бот показывает сохранённый результат и не запускает повторную генерацию.
- После генерации отчёта создаётся запись в `reports`; для платных тарифов отчёт связывается с оплаченной записью `orders`.
- Абстракция `PaymentProvider` отвечает за создание платёжной ссылки и проверку webhook.

## Обслуживание базы данных

- При обновлении схемы базы данных используйте `alembic upgrade head`.
- Миграция `0004_expand_telegram_user_id` расширяет тип Telegram ID до `BIGINT`, чтобы исключить ошибку `integer out of range`.

## Переменные окружения

Минимально необходимые:

- `BOT_TOKEN` — токен Telegram-бота.
- `GEMINI_API_KEY`/`GEMINI_API_KEYS`, `OPENAI_API_KEY`/`OPENAI_API_KEYS` — ключи LLM (если оба провайдера не
  настроены, генерация отчёта блокируется и показывается экран “Сервис временно недоступен”).
- `PRODAMUS_FORM_URL`/`CLOUDPAYMENTS_PUBLIC_ID` — ключи для формирования платёжной ссылки (при отсутствии бот сообщает, что оплата недоступна).

Дополнительные параметры (см. `.env.example`):

- `FEEDBACK_GROUP_CHAT_ID`, `FEEDBACK_GROUP_URL`, `FEEDBACK_MODE`
- `LLM_PRIMARY`, `LLM_FALLBACK`, `LLM_TIMEOUT_SECONDS`
- `REPORT_SAFETY_ENABLED` (включает/отключает post-фильтрацию отчёта)
- `GEMINI_API_KEY`, `GEMINI_API_KEYS`, `GEMINI_MODEL`
- `OPENAI_API_KEY`, `OPENAI_API_KEYS`, `OPENAI_MODEL`
- `PAYMENT_PROVIDER`, `PRODAMUS_FORM_URL`, `PRODAMUS_SECRET`, `PRODAMUS_WEBHOOK_SECRET`,
  `PRODAMUS_STATUS_URL`, `CLOUDPAYMENTS_PUBLIC_ID`, `CLOUDPAYMENTS_API_SECRET`,
  `PAYMENT_WEBHOOK_URL`
- `FREE_T0_COOLDOWN_HOURS`
- `DATABASE_URL`, `PDF_STORAGE_BUCKET`, `PDF_STORAGE_KEY`
- `PDF_FONT_PATH` (путь к TTF-шрифту для PDF, например DejaVuSans)
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION`, `AWS_ENDPOINT_URL` (если используете bucket)
- `ENV`, `LOG_LEVEL`

## Автодеплой

Пошаговые инструкции по автодеплою через GitHub Actions находятся в
[`AUTODEPLOY_INSTRUCTIONS.md`](AUTODEPLOY_INSTRUCTIONS.md).

Ключевые секреты для workflow:
- `SERVICE_NAME` — имя systemd-сервиса или target для перезапуска.
- `SERVICE_NAMES` — опционально, список сервисов/target’ов через пробел (имеет приоритет).
- `ENV_FILE`, `DEPLOY_PATH`, `SSH_HOST`, `SSH_USER`, `SSH_PORT`, `SSH_PRIVATE_KEY` — инфраструктурные параметры.

Workflow запускает `scripts/deploy.sh` на сервере и передаёт ссылку на ветку,
в которую был сделан push (например, `origin/work` или `origin/main`).
По умолчанию workflow настроен на ветки `main` и `work` — убедитесь, что ваш push выполняется
в одну из них или расширьте список веток в `.github/workflows/deploy.yml`.
Проверьте, что unit-файлы созданы и имена сервисов совпадают с тем, что вы передали
в `SERVICE_NAME`/`SERVICE_NAMES`. Если получаете ошибку вида
`...service: command not found`, это признак отсутствующего unit-файла или неверного имени сервиса.
.
