# Numerolog Bot MVP (каркас)

Каркас проекта для Telegram-бота “ИИ-аналитик личных данных”. Стек: **Python + FastAPI + aiogram**.

## Структура проекта

```
.github/workflows     # GitHub Actions (автодеплой)
  deploy.yml          # workflow автодеплоя
alembic/              # миграции Alembic
app/
  api/                # HTTP API (FastAPI)
    routes/
      admin.py         # веб-админка (HTTP UI + API)
  bot/                # Telegram-бот (aiogram)
    handlers/         # обработчики сценариев и FSM ввода профиля
      screen_manager.py # менеджер экранов (очищает чат, ведёт safe-лог переходов экранов и funnel entry/exit)
      screen_images.py # команда /fill_screen_images для генерации картинок экранов
      fallback.py     # обработчик сообщений/кнопок без сценария (очистка и возврат на старт)
    report_jobs_worker.py # фоновые задания генерации отчётов (pending/in_progress)
    markdown.py       # рендеринг Markdown-разметки в Telegram-HTML
    questionnaire/    # конфиг и вспомогательные модули анкеты
  assets/
    screen_images/    # изображения экранов (папки S0/S1/... и S2_T1 и т.д.)
  core/               # конфигурация и общие утилиты
    gemini_image_service.py # сервис генерации изображений через Gemini
    llm_key_store.py  # хранилище и статистика LLM API-ключей (админка -> рантайм)
    llm_router.py     # LLM-маршрутизатор (Gemini -> ChatGPT)
    pdf_service.py    # генерация PDF и слой хранения (bucket/local)
    report_safety.py  # фильтрация запрещённых слов, гарантий и красных зон
    report_service.py # сервис генерации отчёта и каркаса T0-T3
  db/                 # модели и подключение к БД
    models.py         # включает report_jobs, support_dialog_messages и screen_transition_events (аналитика переходов экранов)
  services/           # сервисы бизнес-логики API/бота
    admin_analytics.py # агрегации аналитики переходов экранов (матрица/funnel/drop-off/p95)
  payments/           # платёжные провайдеры и проверки webhook
scripts/              # вспомогательные скрипты
  deploy.sh           # серверный деплой-скрипт (используется GitHub Actions)
  test.sh             # полный набор локальных проверок
  fast_checks.py      # быстрые сценарные проверки без внешних зависимостей
  check_landing_content.py # статическая проверка словаря/дисклеймеров лендинга
web/                  # one-screen лендинг для перехода в Telegram-бот
  index.html          # секции Hero/Преимущества/Тарифы/FAQ/Footer + CTA deep-link
  styles.css          # mobile-first стили (360px+, tablet, desktop)
  script.js           # рендер контента из JSON + FAQ-аккордеон + UTM/deep-link + аналитика
  content/
    landing-content.json # централизованный контент лендинга + словарь проверок
AUTODEPLOY_INSTRUCTIONS.md # пошаговая инструкция по автодеплою
.env.prompts.example # пример файла с системными промптами по тарифам
TZ.md                 # техническое задание (ТЗ)
```

## Предварительные требования

- Python 3.10+
- PostgreSQL (обязательно). Для запуска сервиса необходимо задать `DATABASE_URL`. Без него приложение завершится с ошибкой конфигурации.

## Локальный запуск

1. Создайте виртуальное окружение и установите зависимости:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

2. Скопируйте файл окружения и заполните значения:

```bash
cp .env.example .env
```

3. (Опционально) Скопируйте пример системных промптов и отредактируйте под свои формулировки. Файл используется только если в админке нет сохранённых промптов:

```bash
cp .env.prompts.example .env.prompts
```

4. Настройте ключевые параметры в `.env` (минимум для запуска):

```
BOT_TOKEN=...
DATABASE_URL=postgresql://user:password@localhost:5432/numerolog_bot
# Ограничение пула подключений SQLAlchemy (защита от исчерпания слотов Postgres):
DATABASE_POOL_SIZE=5
DATABASE_MAX_OVERFLOW=5
DATABASE_POOL_TIMEOUT_SECONDS=30
DATABASE_POOL_RECYCLE_SECONDS=1800
# Telegram ID администраторов, которые получают копию обратной связи (через запятую):
ADMIN_IDS=123456789,987654321
# Ссылка на канал проекта для кнопки "Сообщество":
COMMUNITY_CHANNEL_URL=https://t.me/your_project_channel
# Отключение глобального меню в inline-клавиатуре:
GLOBAL_MENU_ENABLED=false
# Управление выводом названий экранов (технический префикс S1/S2/...):
SCREEN_TITLE_ENABLED=true
# Путь к папке с изображениями экранов (см. раздел "Экранные изображения"):
# Если путь относительный, он разрешается относительно корня репозитория.
SCREEN_IMAGES_DIR=app/assets/screen_images
# Логин и пароль доступа к веб-админке (/admin):
ADMIN_LOGIN=admin
ADMIN_PASSWORD=change_me
# Интервал автообновления админки (секунды, 0 отключает):
ADMIN_AUTO_REFRESH_SECONDS=0
# Отключение фильтрации результата (post-фильтр отчёта):
REPORT_SAFETY_ENABLED=true
# Отключение проверки оплаты (тестовый режим):
PAYMENT_ENABLED=true
# Искусственная задержка перед выдачей отчёта (секунды, с анимацией и таймером):
REPORT_DELAY_SECONDS=10
# Report job worker (фоновые задания генерации отчёта)
REPORT_JOB_POLL_INTERVAL_SECONDS=5
REPORT_JOB_LOCK_TIMEOUT_SECONDS=600
# Временная блокировка LLM-ключа при ошибке авторизации (секунды):
LLM_AUTH_ERROR_BLOCK_SECONDS=3600
# Отдельная модель Gemini для генерации изображений экранов:
GEMINI_IMAGE_MODEL=gemini-2.0-flash-exp-image-generation
```

> Примечание: лишние переменные в `.env` безопасно игнорируются и не ломают запуск.

### Локальный просмотр лендинга

```bash
python -m http.server 8080 --directory web
```

После запуска откройте `http://localhost:8080`.

> В `web/index.html` используются Telegram deep-link вида `https://t.me/your_bot_username?start=<utm_tag>`. Перед публикацией замените `your_bot_username` на реальный username вашего бота.

5. Выполните миграции:

```bash
alembic upgrade head
```

6. Запустите API:

```bash
uvicorn app.main:app --reload
```

7. Запустите бота в режиме polling:

```bash
python -m app.bot.polling
```

## Использование бота (основной поток)

1. Откройте бота и выберите тариф на экране **Тарифы**.
2. Для T1–T3 подтвердите оплату, затем заполните экран **Мои данные** (дата, время и место рождения принимаются в любом формате).
3. Для T2/T3 пройдите расширенную анкету — ответы принимаются в произвольном формате без форматирования и валидации, сохраняются после каждого шага и доступны для продолжения.
4. После завершения анкеты (или сразу после профиля для T0/T1) получите отчёт — перед выдачей может применяться искусственная задержка с анимацией и таймером (настраивается через `REPORT_DELAY_SECONDS`), затем PDF формируется автоматически и отправляется в чат. При сбоях генерации или доставки бот вежливо извиняется и повторяет запрос, чтобы пользователь всё равно получил результат.
   Сообщения с PDF-отчётами удаляются при переходе на следующий экран, а бот дополнительно сообщает, что отчёт сохранён в личном кабинете.
   Генерация запускается через фоновые задания (report_jobs). Экран S6 ставит задачу в очередь, а воркер автоматически доводит её до завершения, в том числе после рестарта. Если задача не завершилась, на S6/S7 доступна кнопка «Повторить генерацию».
5. В отчёте (S7/S13) и в личном кабинете (S11) доступна кнопка **«Сообщество»**, ведущая в канал проекта (настраивается через `COMMUNITY_CHANNEL_URL`). В личном кабинете также есть кнопка **«Обратная связь»** для перехода на экран отправки сообщения в админку.
6. Команда `/lk` открывает экран личного кабинета (S11) с краткой сводкой профиля, сохранённым профилем расширенной анкеты и доступом к отчётам (повторное открытие, загрузка PDF и удаление).
7. Команда `/fill_screen_images` запрашивает универсальный промпт, запускает генерацию изображений через Gemini для каждого каталога экранов и сохраняет картинки локально. После завершения выводится отчёт с детализацией по экранам, сообщение автоудаляется через минуту или по кнопке «Закрыть отчёт». При rate limit (429) генерация останавливается, чтобы не засорять логи, а отчёт подсказывает время повторной попытки.

## Экранные изображения

- Бот отправляет изображения экранов, если в каталоге экрана есть файлы **.png/.jpg/.jpeg/.webp**. Остальные файлы (`.gitkeep`, `description.txt`) игнорируются.
- Текст экрана уходит **в одной и той же карточке** с изображением (caption), чтобы картинка и текст были единым сообщением.
- Если текст превышает лимит подписи Telegram, бот отправляет картинку отдельно, а весь текст — следующими сообщениями, чтобы отчёт не обрезался.
- Если изображения отсутствуют, экран показывается только текстом без ошибки.
- Путь `SCREEN_IMAGES_DIR` можно задавать абсолютным или относительным (относительный путь считается от корня репозитория).

## Веб-админка (мониторинг и управление)

Админка доступна по HTTP на адресе `http://<host>:<port>/admin` после запуска API.  
Для доступа используются логин и пароль из `.env` (`ADMIN_LOGIN`/`ADMIN_PASSWORD`): при открытии страницы появится экран входа, после чего админка откроется и сохранит сессию в cookie для последующих запросов.  
Интервал автообновления разделов админки задаётся переменной `ADMIN_AUTO_REFRESH_SECONDS` (0 отключает автообновление).  

Что доступно:
- сводка по пользователям/заказам/отчётам/обратной связи;
- контроль состояния базы данных;
- раздел **«LLM ключи»** для добавления/отключения ключей Gemini/OpenAI с выбором провайдера из выпадающего списка (и возможностью указать свой), управления приоритетом, просмотра статистики использования (последние ошибки/успехи) и длительности отключения неактивных ключей; список ключей разделён на вкладки **«Активные»** и **«Неактивные»** для быстрого контроля состояния;
- массовая загрузка LLM-ключей из файла: каждая строка — отдельный ключ, провайдер выбирается в интерфейсе и применяется ко всем строкам, значения сохраняются как есть;
- просмотр заказов, отчётов, пользователей и входящей обратной связи в отдельном разделе;
- в разделе **«Обратная связь»** администратор может вручную отправить ответ пользователю прямо из админки; текст ответа сохраняется в БД и помечается временем отправки;
- поиск по таблицам админки по любому столбцу и сортировка кликом по заголовкам;
- копирование содержимого любой ячейки таблицы одним кликом по тексту;
- ручная смена статуса заказа (оплачен/ошибка);
- журнал админ-заметок (любой формат данных сохраняется как есть);
- отдельный раздел **«Системные промпты»** для добавления, изменения и удаления системных промптов; ключи выбираются из выпадающего списка PROMPT_T0–PROMPT_T3, при необходимости доступен ввод собственного ключа (при наличии промптов в админке файл `.env.prompts` игнорируется).  
- обратная связь дополнительно отправляется в Telegram администраторам, если заполнен `ADMIN_IDS` (через запятую).  

Интерфейс админки построен в виде левого меню разделов и правой рабочей области, где отображается только выбранный раздел.  

> Важно: админка не предназначена для публичного доступа — обязательно используйте сложные `ADMIN_LOGIN` и `ADMIN_PASSWORD` и при необходимости ограничьте доступ по сети/фаерволу.

Дополнительно: при старте приложения ключи из `.env` автоматически синхронизируются в БД (если в БД пусто). Это позволяет сразу видеть статистику использования в разделе **«LLM ключи»** даже без ручного ввода в админке.

## Локальная отладка

### Запуск через tmux (только для локальной отладки, **не для продакшена**)

1. Установите tmux и создайте сессию:

```bash
sudo apt install tmux
tmux new -s numerolog_bot
```

2. Запустите API в первой панели:

```bash
source .venv/bin/activate
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

3. Разделите окно на две панели и запустите бота:

```bash
tmux split-window -h
source .venv/bin/activate
python -m app.bot.polling
```

4. Выйдите из tmux без остановки процессов:

```bash
tmux detach
```

5. Чтобы вернуться в сессию:

```bash
tmux attach -t numerolog_bot
```

> Для продакшена используйте **только** `systemd`, чтобы гарантировать один экземпляр процесса и автозапуск при перезагрузке сервера. Ручные запуски и `tmux` в продакшене не используйте.

## Проверки

Быстрые сценарные проверки (без внешних зависимостей по умолчанию):

```bash
bash scripts/test.sh
```

Сценарии включают:
- T0 cooldown,
- оплата → генерация,
- fallback LLM,
- webhook-валидация провайдеров,
- повторная выдача PDF.

## Ревью текстов лендинга

Источник всех текстов лендинга: `web/content/landing-content.json`.

Перед публикацией контентных изменений обязательно:

```bash
python scripts/check_landing_content.py
```

Подробный регламент: `docs/landing/review-rules.md`.

## Контентная безопасность

После генерации отчёта применяется post-фильтр: запрещённая лексика, паттерны гарантий/предсказаний и «красные зоны».  
Если обнаружены нарушения, выполняется регенерация (до 2 раз).  
Если текст по-прежнему содержит «красные зоны», бот возвращает безопасный отказ.  
Если нарушения остаются без красных зон, бот выдаёт резервный безопасный отчёт.  
Флаги фильтрации сохраняются в `reports.safety_flags`.
При необходимости можно отключить post-фильтр через `REPORT_SAFETY_ENABLED=false` (текст отправляется без проверки).  

## LLM fallback

- Основной провайдер — Gemini, fallback — OpenAI.
- При любой ошибке Gemini бот сначала перебирает оставшиеся ключи Gemini, а затем автоматически переключается на OpenAI.
- Для Gemini системные инструкции передаются через `systemInstruction`, а данные — отдельным блоком `facts-pack`, чтобы избежать ошибок валидации запроса.
- При 429 применяется увеличенный backoff (с учётом `Retry-After`, если он задан), а ключ временно блокируется в памяти (circuit breaker), чтобы снизить риск повторных rate-limit.
- При 401/403 ключ временно отключается на время `LLM_AUTH_ERROR_BLOCK_SECONDS`, чтобы избежать бесконечных повторов с неверными ключами.
- Ключи из `.env` автоматически появляются в админке, поэтому статистика их использования обновляется в таблице **«LLM ключи»** без ручной загрузки.
- Если в админке добавлены LLM-ключи, они используются в приоритетном порядке, а ключи из `.env` остаются резервом на случай отсутствия валидных активных ключей в базе (включая многострочные списки).
- При использовании LLM-ключей автоматически игнорируются BOM, переводы строк и пробелы по краям (значения в `.env` и БД сохраняются как есть).
- Ключи из таблицы `llm_api_keys` с `is_active=NULL` считаются активными и используются наравне с `is_active=true`, чтобы не терять ключи при старых миграциях.
- Если ключ из `.env` был добавлен в админку и помечен как неактивный, он исключается из пула ключей (и не участвует в подсчёте количества попыток генерации).
- Ключи с пустым провайдером из админки добавляются к пулу ключей конкретного провайдера и используются вместе с ним.
- Повтор генерации отчёта на уровне сценария выполняется минимум 2 раза, а при большем числе доступных LLM-ключей количество попыток увеличивается до их общего числа (с учётом ключей Gemini и OpenAI), чтобы максимально использовать пул ключей перед показом экрана недоступности.
- Если итоговый список LLM-ключей пуст, сервис пишет INFO-лог с провайдером, количеством ключей из БД и окружения, признаком отсутствия `DATABASE_URL` и его значением (или `missing`) для быстрой диагностики конфигурации.


## Админ-аналитика переходов экранов

Доступны API-эндпоинты:
- `GET /admin/api/analytics/screen-transitions` (совместимый агрегированный ответ),
- `GET /admin/api/analytics/transitions/summary`,
- `GET /admin/api/analytics/transitions/matrix`,
- `GET /admin/api/analytics/transitions/funnel`,
- `GET /admin/api/analytics/transitions/timing`.

Общие query-параметры и ограничения:
- `from`, `to` — период (ISO datetime),
- `tariff` — тариф (например, `T0`...`T3`),
- `trigger_type` — тип триггера (`callback|message|system|job|admin|unknown`),
- `unique_users_only` — считать только уникальных пользователей,
- `dropoff_window_minutes` — окно для drop-off в минутах (`1..1440`),
- `limit` — верхняя граница выбираемых событий (`1..50000`),
- `top_n` — ограничение длины выдачи для списков (`1..500`),
- `screen_id` — повторяемый фильтр по whitelist экранов (`S0..S14`).

Стабильный контракт ответа для фронта:
- `generated_at`,
- `filters_applied`,
- `data` (строго типизированные поля выбранного среза),
- `warnings` (например, при малом объёме данных).

Неизвестные экраны нормализуются в `UNKNOWN`, пустые выборки возвращаются как корректные пустые JSON-массивы.

## Автодеплой

Подробные пошаговые инструкции по настройке автодеплоя описаны в `AUTODEPLOY_INSTRUCTIONS.md`.

## Системные промпты по тарифам

Системные промпты можно управлять через веб-админку (раздел **«Системные промпты»**).  
Промпты, сохранённые в админке, имеют приоритет: если в базе есть хотя бы один промпт, файл `.env.prompts` полностью игнорируется.  
Если в админке нет промптов, то используются значения из `.env.prompts` (переменные `PROMPT_T0`, `PROMPT_T1`, `PROMPT_T2`, `PROMPT_T3`) либо встроенные безопасные значения.  
Пример заполнения находится в `.env.prompts.example`.

## Запуск через systemd

`systemd` обеспечивает запуск **ровно одного экземпляра** сервиса (API и бота) и автоматический рестарт при сбоях.

### Пример unit-файла для API (`/etc/systemd/system/numerolog-api.service`)

```ini
[Unit]
Description=Numerolog Bot API (FastAPI)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/uvicorn app.main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Пример unit-файла для бота (`/etc/systemd/system/numerolog-bot.service`)

```ini
[Unit]
Description=Numerolog Bot (Telegram, aiogram)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/python -m app.bot.polling
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Управление сервисами

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog-api.service
sudo systemctl enable --now numerolog-bot.service
```

**Стандартный способ перезапуска после деплоя (гарантирует одиночные процессы и предотвращает размножение инстансов):**

```bash
sudo systemctl restart numerolog-api.service
sudo systemctl restart numerolog-bot.service
```

### Пример target для общего управления

Если хотите управлять API и ботом одной командой, создайте target:

```ini
# /etc/systemd/system/numerolog.target
[Unit]
Description=Numerolog Bot (API + Bot)
Requires=numerolog-api.service numerolog-bot.service
After=network.target
```

Команды:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog.target
sudo systemctl restart numerolog.target
```

## Использование

- Откройте чат с ботом в Telegram и нажмите **Start** — на стартовом экране доступны кнопки **«Тарифы»**, **«Оферта»**, **«Обратная связь»** с одной иконкой перед текстом.
- После перехода на экран тарифов показываются четыре CTA-кнопки в одном столбце с соответствующими иконками: «Твоё новое начало», «В чём твоя сила?», «Где твои деньги?», «Твой путь к себе!» (глобальное меню на этом экране скрыто).
- Для T0 бот сразу запускает пошаговый ввод профиля (имя, дата, время, место рождения), а для T1–T3 мастер ввода стартует после подтверждения оплаты.
- В тарифах T2/T3 после профиля запускается лайтовая анкета из `app/bot/questionnaire/questionnaire_v1.json` с сохранением прогресса и поддержкой типов text/choice/scale; ответы принимаются в произвольном формате без форматирования и валидации.
- Управляйте сценариями через inline-клавиатуру: тарифы, оферта, обратная связь (в большинстве экранов).
- Все тексты экранов могут начинаться с технического идентификатора экрана (например, `S1:`), чтобы быстрее сверять сценарии с кодом; префикс включается через `SCREEN_TITLE_ENABLED`.
- Экран “Мои данные” работает в режиме просмотра и показывает сохранённые поля профиля.
- Если тариф ещё не выбран, кнопка “Мои данные” возвращает к выбору тарифа, чтобы соблюсти порядок экранов.
- Для платных тарифов без подтверждённой оплаты экран “Мои данные” показывает кнопку перехода к оплате и блокирует старт мастера ввода.
- На экране “Мои данные” всегда доступна кнопка “Назад” для возврата к тарифам.
- Если профиль уже заполнен, на экране “Мои данные” доступна кнопка “Удалить мои данные” — она открывает подтверждение с кнопками «Да/Отмена» и очищает все данные пользователя, сохраняя учётную запись.
- Экран оплаты открывается только после перехода через оферту (S2 → S3), чтобы зафиксировать согласие с условиями.
- Для заполнения профиля нажмите “Заполнить данные” и последовательно введите имя, дату рождения, время рождения и место рождения в любом формате.
- Если профиль уже заполнен, кнопка “Редактировать” открывает частичное редактирование по полям без потери остальных данных.
- После выбора тарифа “Т0 - Твоё новое начало (бесплатно)” показывается отдельный экран с описанием превью и
  кнопками “Старт”, “Назад” и “Обратная связь” (без пунктов “Оферта” и “Мои данные” на этом экране).
- Если лимит T0 исчерпан, экран уведомления (S9) показывает одну кнопку “Назад” и возвращает к тарифам.
- Глобальное меню (Тарифы, Мои данные, Оферта, Обратная связь) доступно на большинстве ключевых экранов
  (кроме экрана тарифов после «Далее...» и экрана превью T0).
- Для платных тарифов создаётся заказ в БД, оплата подтверждается перед генерацией отчёта.
- Для тарифа Т0 действует лимит 1 раз в месяц (настраивается через `FREE_T0_COOLDOWN_HOURS`).
- Для тарифов T2/T3 после профиля запускается анкета (конфиг `app/bot/questionnaire/questionnaire_v1.json`) и доступна только после подтверждённой оплаты; ответы принимаются в произвольном формате без форматирования и валидации.
- Прогресс анкеты сохраняется в БД и может быть продолжен с того же шага.
- После завершения анкеты доступна кнопка «Редактировать анкету», которая запускает повторный проход без сброса сохранённых ответов.
- После заполнения анкеты появляется кнопка «Редактировать данные», чтобы вернуться к экрану профиля и обновить сведения перед запуском генерации отчёта.
- Состояние экранов сохраняется в таблице `screen_states`, поэтому при рестарте процесса выбор тарифа
  и данные экранов восстанавливаются из БД; там же хранится список `user_message_ids`, чтобы удалять
  пользовательские сообщения при переходах между экранами.
- После успешной генерации отчёт сохраняется в таблице `reports`, а при повторном просмотре экрана S7 текст подтягивается из БД.
- На экране S7 доступна кнопка «Назад», возвращающая к тарифам.
- На всех экранах поддерживается Markdown-разметка (жирный/курсив/подчёркивание/зачёркивание, спойлеры, ссылки, инлайн-код и блоки кода) — перед отправкой сообщения автоматически конвертируются в Telegram-HTML. Если текст уже содержит Telegram-HTML теги (например, `<b>`/`<i>`), они сохраняются и отображаются корректно.
- После генерации отчёта выполняется фильтрация: запрещённые слова/паттерны “гарантий/предсказаний” вызывают регенерацию (до 2 попыток), при «красных зонах» выдаётся безопасный отказ, а при остальных нарушениях — резервный безопасный отчёт.
- Информация о фильтрации записывается в `reports.safety_flags`.
- При переходах между экранами бот удаляет предыдущие сообщения, пользовательские ответы и inline-клавиатуры (включая шаги анкеты и мастера профиля). Пользовательские сообщения удаляются сразу после обработки, а если Telegram не позволяет удалить сообщение — бот редактирует его в нейтральный текст без клавиатуры.
- Запросы к LLM идут в Gemini как к основному провайдеру, при любой ошибке выполняется перебор всех доступных ключей Gemini, и только после их исчерпания выполняется fallback на ChatGPT с ограниченными ретраями (до 2 на Gemini и до 1 на ChatGPT). При наличии нескольких API-ключей каждого провайдера выполняется автоматический перебор ключей до fallback.
- PDF формируется автоматически сразу после генерации отчёта и сохраняется в `reports.pdf_storage_key`. Кнопка “Выгрузить PDF” остаётся для повторных скачиваний.
- Telegram ID пользователя хранится в `users.telegram_user_id` и `screen_states.telegram_user_id` как `BIGINT`, чтобы корректно обрабатывать большие значения.
- Для каждого экрана можно подключить локальную картинку: бот ищет её в папке `SCREEN_IMAGES_DIR` и, если находит, отправляет перед текстом экрана.

## Обратная связь (экран S8)

В экране “Обратная связь” пользователь пишет текстовое сообщение, после чего бот отправляет его
в админку автоматически (без отдельной кнопки “Отправить”).
Сообщение пересылается администраторам из `ADMIN_IDS` и сохраняется в `feedback_messages`
со статусом `sent`/`failed`. Отправка в группу отключена.

## PDF-хранение

- По умолчанию PDF сохраняются локально в каталог `storage/pdfs` (или другой путь, заданный через `PDF_STORAGE_KEY`).
- Если указать `PDF_STORAGE_BUCKET`, файлы сохраняются в S3-совместимом бакете. `PDF_STORAGE_KEY` используется как префикс ключа.
- Для bucket-хранилища задайте переменные `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION` и при необходимости `AWS_ENDPOINT_URL`.
- Для корректной кириллицы задайте `PDF_FONT_PATH` (например, `/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf`): при генерации PDF используется этот пользовательский шрифт, а при отсутствии файла — встроенный резервный.
- PDF генерируется автоматически сразу после формирования отчёта, а повторные скачивания используют сохранённый `reports.pdf_storage_key` (если доступно хранилище). Кнопка «Выгрузить PDF» остаётся для ручной повторной выдачи.
- При переходе на следующий экран PDF-сообщение автоматически удаляется, а пользователь получает уведомление о сохранении отчёта в личном кабинете.
- Если `PDF_STORAGE_BUCKET` не задан, S3-хранилище не удалось инициализировать (например, отсутствует `boto3`) или запись в бакет завершилась ошибкой, сервис автоматически использует локальный каталог и всё равно сохраняет `reports.pdf_storage_key`.
- Имя PDF-файла формируется автоматически и содержит `@username`, тариф и время получения отчёта, чтобы файл был легко узнаваемым в истории загрузок.

## Анкета T2/T3

- Конфигурация анкеты хранится в `app/bot/questionnaire/questionnaire_v1.json`.
- Поддерживаются типы вопросов: `text`, `choice`, `scale`, обязательность и переходы по логике; ответы принимаются в произвольном формате без форматирования и валидации.
- В текущей версии анкеты все вопросы настроены как свободный ввод без обязательного формата.
- Ответы сохраняются по мере ввода и используются при формировании facts-pack для LLM.
- Webhook оплаты принимает запросы на `/webhooks/payments` и проверяет подпись провайдера.
- Если основной провайдер недоступен или не сконфигурирован, бот пробует сформировать ссылку через CloudPayments и обновляет `orders.provider` для корректной проверки статуса.
- При отсутствии параметра `provider` в webhook-URL API пытается валидировать подпись сначала основным провайдером, затем fallback-провайдером.
- Кнопка “Я оплатил(а)” запрашивает статус у платёжного провайдера и переводит на ввод данных
  только после подтверждения оплаты.
- Генерация отчётов использует LLM-маршрутизатор: Gemini (основной) с 1–2 ретраями на 5xx/timeout,
  перебором всех доступных ключей Gemini при любой ошибке и fallback на ChatGPT только после исчерпания ключей (у ChatGPT — 1 retry на transient).
  Если указаны несколько ключей для провайдера, они перебираются автоматически при ошибках/недоступности.
- Перед отправкой в LLM формируется facts-pack (JSON) с исходными полями профиля и анкеты
  без нормализации и валидации: пользовательские строки передаются как есть.
- Если недоступны оба провайдера, бот показывает экран “Сервис временно недоступен”.
- Если ключи LLM не настроены ни в `.env` (нет `GEMINI_API_KEY`/`GEMINI_API_KEYS` и `OPENAI_API_KEY`/`OPENAI_API_KEYS`),
  ни в админке (раздел «LLM ключи»), бот сразу показывает экран “Сервис временно недоступен”
  и не запускает генерацию.
- Команда `/lk` открывает экран “Личный кабинет” (S11) и показывает сохранённые данные профиля и расширенной анкеты без форматирования.
- В кабинете доступен список “Мои отчёты” с кнопками “Открыть”, “Выгрузить PDF” и “Удалить”, чтобы повторно использовать или удалить сохранённые отчёты.

## Логика тарифов и оплат

- Т0 можно запросить только после окончания cooldown: бот сверяет `last_t0_at` в таблице `free_limits`.
- Для T1–T3 бот создаёт запись в `orders` со статусом `created` и показывает экран оплаты.
- Генерация отчёта доступна **только** после статуса `paid`.
- Для платных тарифов действует правило «одна оплата — один отчёт»: если отчёт уже создан для заказа, бот показывает сохранённый результат и не запускает повторную генерацию.
- После генерации отчёта создаётся запись в `reports`; для платных тарифов отчёт связывается с оплаченной записью `orders`.
- Абстракция `PaymentProvider` отвечает за создание платёжной ссылки и проверку webhook.

## Обслуживание базы данных

- При обновлении схемы базы данных используйте `alembic upgrade head`.
- Миграция `0004_expand_telegram_user_id` расширяет тип Telegram ID до `BIGINT`, чтобы исключить ошибку `integer out of range`.

## Переменные окружения

Минимально необходимые:

- `BOT_TOKEN` — токен Telegram-бота.
- `GEMINI_API_KEY`/`GEMINI_API_KEYS`, `OPENAI_API_KEY`/`OPENAI_API_KEYS` — ключи LLM (если ключей нет и в `.env`,
  и в админке, генерация отчёта блокируется и показывается экран “Сервис временно недоступен”).
- `PRODAMUS_FORM_URL`/`CLOUDPAYMENTS_PUBLIC_ID` — ключи для формирования платёжной ссылки (при отсутствии бот сообщает, что оплата недоступна).
  Если в веб-админке заведены LLM-ключи, значения из `.env` для LLM игнорируются.
- `ADMIN_LOGIN` — логин доступа к веб-админке.
- `ADMIN_PASSWORD` — пароль доступа к веб-админке.

Дополнительные параметры (см. `.env.example`):
- `LLM_PRIMARY`, `LLM_FALLBACK`, `LLM_TIMEOUT_SECONDS`
- `REPORT_SAFETY_ENABLED` (включает/отключает post-фильтрацию отчёта)
- `SCREEN_TITLE_ENABLED` (включает/отключает показ технического идентификатора экрана в тексте)
- `SCREEN_IMAGES_DIR` (путь к локальному хранилищу изображений экранов)
- `GEMINI_API_KEY`, `GEMINI_API_KEYS`, `GEMINI_MODEL`, `GEMINI_IMAGE_MODEL`
- `OPENAI_API_KEY`, `OPENAI_API_KEYS`, `OPENAI_MODEL`
- `PAYMENT_PROVIDER`, `PRODAMUS_FORM_URL`, `PRODAMUS_SECRET`, `PRODAMUS_WEBHOOK_SECRET`,
  `PRODAMUS_STATUS_URL`, `CLOUDPAYMENTS_PUBLIC_ID`, `CLOUDPAYMENTS_API_SECRET`,
  `PAYMENT_WEBHOOK_URL`
- `FREE_T0_COOLDOWN_HOURS`
- `DATABASE_URL`, `PDF_STORAGE_BUCKET`, `PDF_STORAGE_KEY`
- `PDF_FONT_PATH` (путь к TTF-шрифту для PDF, например DejaVuSans)
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION`, `AWS_ENDPOINT_URL` (если используете bucket)
- `ENV`, `LOG_LEVEL`
- `MONITORING_WEBHOOK_URL` (вебхук мониторинга для события `report_generate_failed`)

## Поддержка и история переписки

- Каждое сообщение пользователя в поддержку сохраняется в `feedback_messages` и дополнительно в `support_dialog_messages` с направлением `user`.
- Каждый ответ администратора пользователю сохраняется в `support_dialog_messages` с направлением `admin`.
- Для каждого диалога используется `thread_feedback_id`, что позволяет хранить полную цепочку сообщений (включая быстрые ответы пользователя на сообщения поддержки).
- В сообщении от поддержки пользователю отправляется inline-кнопка **«Ответить поддержке»**, которая мгновенно открывает экран обратной связи (S8) в нужном треде.
- В админке (раздел «Обратная связь») доступна кнопка **«История треда»** — она показывает полную историю диалога по `thread_feedback_id` на одном экране.


## Админ-аналитика переходов экранов

Доступны API-эндпоинты:
- `GET /admin/api/analytics/screen-transitions` (совместимый агрегированный ответ),
- `GET /admin/api/analytics/transitions/summary`,
- `GET /admin/api/analytics/transitions/matrix`,
- `GET /admin/api/analytics/transitions/funnel`,
- `GET /admin/api/analytics/transitions/timing`.

Общие query-параметры и ограничения:
- `from`, `to` — период (ISO datetime),
- `tariff` — тариф (например, `T0`...`T3`),
- `trigger_type` — тип триггера (`callback|message|system|job|admin|unknown`),
- `unique_users_only` — считать только уникальных пользователей,
- `dropoff_window_minutes` — окно для drop-off в минутах (`1..1440`),
- `limit` — верхняя граница выбираемых событий (`1..50000`),
- `top_n` — ограничение длины выдачи для списков (`1..500`),
- `screen_id` — повторяемый фильтр по whitelist экранов (`S0..S14`).

Стабильный контракт ответа для фронта:
- `generated_at`,
- `filters_applied`,
- `data` (строго типизированные поля выбранного среза),
- `warnings` (например, при малом объёме данных).

Неизвестные экраны нормализуются в `UNKNOWN`, пустые выборки возвращаются как корректные пустые JSON-массивы.

## Автодеплой

Пошаговые инструкции по автодеплою через GitHub Actions находятся в
[`AUTODEPLOY_INSTRUCTIONS.md`](AUTODEPLOY_INSTRUCTIONS.md).

Ключевые секреты для workflow:
- `SERVICE_NAME` — имя systemd-сервиса или target для перезапуска.
- `SERVICE_NAMES` — опционально, список сервисов/target’ов через пробел (имеет приоритет).
- `ENV_FILE`, `DEPLOY_PATH`, `SSH_HOST`, `SSH_USER`, `SSH_PORT`, `SSH_PRIVATE_KEY` — инфраструктурные параметры.

Workflow запускает `scripts/deploy.sh` на сервере и передаёт ссылку на ветку,
в которую был сделан push (например, `origin/work` или `origin/main`).
По умолчанию workflow настроен на ветки `main` и `work` — убедитесь, что ваш push выполняется
в одну из них или расширьте список веток в `.github/workflows/deploy.yml`.
Проверьте, что unit-файлы созданы и имена сервисов совпадают с тем, что вы передали
в `SERVICE_NAME`/`SERVICE_NAMES`. Если получаете ошибку вида
`...service: command not found`, это признак отсутствующего unit-файла или неверного имени сервиса.
.

## Экранные изображения

Бот отображает картинку для каждого экрана, если она есть в локальном хранилище.
Папка задаётся через `SCREEN_IMAGES_DIR` (по умолчанию `app/assets/screen_images`). Внутри должны быть
каталоги с именами экранов:

- Статичные экраны: `S0`, `S1`, `S8`, `S9`, `S10`, `S11`, `S12`.
- Тариф-зависимые экраны: `S2_T0`, `S2_T1`, `S2_T2`, `S2_T3` (аналогично для `S3`, `S4`, `S5`, `S6`, `S7`).
- Экраны просмотра/удаления отчёта: `S13_T0`...`S13_T3`, `S14_T0`...`S14_T3`.

В каждом каталоге достаточно разместить **любой один файл изображения** (формат и имя не важны).
Дополнительно в каждом каталоге размещён файл `description.txt` с кратким описанием экрана и условия его показа.
Если файл отсутствует — экран продолжит работать без картинки.
Для автоматической генерации картинок используйте команду `/fill_screen_images`: она запросит универсальный промпт,
затем через Gemini с моделью `GEMINI_IMAGE_MODEL` создаст изображения для каждого каталога и сохранит их локально.
Если Gemini вернёт 429, генерация остановится и подскажет, когда повторить попытку.


## Обратная связь в админке

- В разделе **«Обратная связь»** добавлены две вкладки: **«Текущие»** и **«Архив»**.
- Поддерживается единичный перевод обращения в архив/обратно через кнопку в строке таблицы.
- Поддерживаются массовые действия: архивирование выбранных обращений и возврат выбранных архивных обращений в текущие.
- Данные разделяются на уровне API: `/admin/api/feedback/inbox` (текущие) и `/admin/api/feedback/archive` (архив).


## Аналитика переходов экранов

- Каждый вызов `show_screen(...)` записывает событие в `screen_transition_events` с `from_screen_id`, `to_screen_id`, `trigger_type`, `trigger_value` и статусом (`success|blocked|error`).
- Ошибки записи аналитики не влияют на UX: событие пишется через fail-safe метод и при ошибке только логируется warning.
- Дополнительно фиксируются события входа в воронку (первый переход на `S1`) и выхода (успешная выдача результата `S7` или timeout-сценарии при передаче `metadata_json.reason`).


## Аналитика one-screen лендинга

- Документация по UTM, KPI и валидации: `docs/landing/analytics.md`.
- Frontend автоматически формирует `start` для Telegram deep-link с `source/campaign/placement`.
- Отправляются события: `landing_hero_view`, `landing_cta_click`, `landing_tariff_click`, `landing_faq_reach` (через `dataLayer`/`gtag`, если они подключены).

