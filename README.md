# Numerolog Bot MVP (каркас)

Каркас проекта для Telegram-бота “ИИ-аналитик личных данных”. Стек: **Python + FastAPI + aiogram**.

## Структура проекта

```
.github/workflows     # GitHub Actions (автодеплой)
  deploy.yml          # workflow автодеплоя
alembic/              # миграции Alembic
app/
  api/                # HTTP API (FastAPI)
    routes/
      admin.py         # веб-админка (HTTP UI + API)
  bot/                # Telegram-бот (aiogram)
    handlers/         # обработчики сценариев и FSM ввода профиля
      screen_manager.py # менеджер экранов (хранит message_ids и user_message_ids, очищает чат)
      screen_images.py # команда /fill_screen_images для генерации картинок экранов
      fallback.py     # обработчик сообщений/кнопок без сценария (очистка и возврат на старт)
    questionnaire/    # конфиг и вспомогательные модули анкеты
  assets/
    screen_images/    # изображения экранов (папки S0/S1/... и S2_T1 и т.д.)
  core/               # конфигурация и общие утилиты
    gemini_image_service.py # сервис генерации изображений через Gemini
    llm_key_store.py  # хранилище и статистика LLM API-ключей (админка -> рантайм)
    llm_router.py     # LLM-маршрутизатор (Gemini -> ChatGPT)
    pdf_service.py    # генерация PDF и слой хранения (bucket/local)
    report_safety.py  # фильтрация запрещённых слов, гарантий и красных зон
    report_service.py # сервис генерации отчёта и каркаса T0-T3
  db/                 # модели и подключение к БД
  payments/           # платёжные провайдеры и проверки webhook
scripts/              # вспомогательные скрипты
  deploy.sh           # серверный деплой-скрипт (используется GitHub Actions)
  test.sh             # локальные проверки
  fast_checks.py      # быстрые сценарные проверки без внешних зависимостей
AUTODEPLOY_INSTRUCTIONS.md # пошаговая инструкция по автодеплою
.env.prompts.example # пример файла с системными промптами по тарифам
TZ.md                 # техническое задание (ТЗ)
```

## Предварительные требования

- Python 3.10+
- PostgreSQL (рекомендуется для продакшена). Если `DATABASE_URL` не задан, сервис автоматически использует локальный SQLite-файл `storage/numerolog_bot.sqlite3` для минимального запуска.

## Локальный запуск

1. Создайте виртуальное окружение и установите зависимости:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

2. Скопируйте файл окружения и заполните значения:

```bash
cp .env.example .env
```

3. (Опционально) Скопируйте пример системных промптов и отредактируйте под свои формулировки. Файл используется только если в админке нет сохранённых промптов:

```bash
cp .env.prompts.example .env.prompts
```

4. Настройте ключевые параметры в `.env` (минимум для запуска):

```
BOT_TOKEN=...
DATABASE_URL=postgresql://user:password@localhost:5432/numerolog_bot
# Ссылка на канал проекта для кнопки "Сообщество":
COMMUNITY_CHANNEL_URL=https://t.me/your_project_channel
# Отключение глобального меню в inline-клавиатуре:
GLOBAL_MENU_ENABLED=false
# Управление выводом названий экранов (технический префикс S1/S2/...):
SCREEN_TITLE_ENABLED=true
# Путь к папке с изображениями экранов (см. раздел "Экранные изображения"):
# Если путь относительный, он разрешается относительно корня репозитория.
SCREEN_IMAGES_DIR=app/assets/screen_images
# Ключ доступа к веб-админке (/admin):
ADMIN_API_KEY=change_me
# Отключение фильтрации результата (post-фильтр отчёта):
REPORT_SAFETY_ENABLED=true
# Отключение проверки оплаты (тестовый режим):
PAYMENT_ENABLED=true
# Искусственная задержка перед выдачей отчёта (секунды, с анимацией и таймером):
REPORT_DELAY_SECONDS=0
# Отдельная модель Gemini для генерации изображений экранов:
GEMINI_IMAGE_MODEL=gemini-2.0-flash-exp-image-generation
```

5. Выполните миграции:

```bash
alembic upgrade head
```

6. Запустите API:

```bash
uvicorn app.main:app --reload
```

7. Запустите бота в режиме polling:

```bash
python -m app.bot.polling
```

## Использование бота (основной поток)

1. Откройте бота и выберите тариф на экране **Тарифы**.
2. Для T1–T3 подтвердите оплату, затем заполните экран **Мои данные** (дата, время и место рождения принимаются в любом формате).
3. Для T2/T3 пройдите расширенную анкету — ответы принимаются в произвольном формате без форматирования и валидации, сохраняются после каждого шага и доступны для продолжения.
4. После завершения анкеты (или сразу после профиля для T0/T1) получите отчёт — перед выдачей может применяться искусственная задержка с анимацией и таймером (настраивается через `REPORT_DELAY_SECONDS`), затем PDF формируется автоматически и отправляется в чат. При сбоях генерации или доставки бот вежливо извиняется и повторяет запрос, чтобы пользователь всё равно получил результат.
   Сообщения с PDF-отчётами удаляются при переходе на следующий экран, а бот дополнительно сообщает, что отчёт сохранён в личном кабинете.
5. В отчёте (S7/S13) и в личном кабинете (S11) доступна кнопка **«Сообщество»**, ведущая в канал проекта (настраивается через `COMMUNITY_CHANNEL_URL`).
6. Команда `/lk` открывает экран личного кабинета (S11) с краткой сводкой профиля, сохранённым профилем расширенной анкеты и доступом к отчётам (повторное открытие, загрузка PDF и удаление).
7. Команда `/fill_screen_images` запрашивает универсальный промпт, запускает генерацию изображений через Gemini для каждого каталога экранов и сохраняет картинки локально. После завершения выводится отчёт с детализацией по экранам, сообщение автоудаляется через минуту или по кнопке «Закрыть отчёт». При rate limit (429) генерация останавливается, чтобы не засорять логи, а отчёт подсказывает время повторной попытки.

## Экранные изображения

- Бот отправляет изображения экранов, если в каталоге экрана есть файлы **.png/.jpg/.jpeg/.webp**. Остальные файлы (`.gitkeep`, `description.txt`) игнорируются.
- Текст экрана уходит **в одной и той же карточке** с изображением (caption), чтобы картинка и текст были единым сообщением.
- Если текст превышает лимит подписи Telegram, он автоматически укорачивается с многоточием, чтобы избежать ошибок отправки.
- Если изображения отсутствуют, экран показывается только текстом без ошибки.
- Путь `SCREEN_IMAGES_DIR` можно задавать абсолютным или относительным (относительный путь считается от корня репозитория).

## Веб-админка (мониторинг и управление)

Админка доступна по HTTP на адресе `http://<host>:<port>/admin` после запуска API.  
Для доступа нужен ключ `ADMIN_API_KEY` из `.env` — введите его в интерфейсе (ключ хранится только в localStorage браузера).  

Что доступно:
- сводка по пользователям/заказам/отчётам/обратной связи;
- контроль состояния базы данных;
- раздел **«LLM ключи»** для добавления/отключения ключей Gemini/OpenAI с выбором провайдера из выпадающего списка (и возможностью указать свой), управления приоритетом и просмотра статистики использования (последние ошибки/успехи);
- массовая загрузка LLM-ключей из файла: каждая строка — отдельный ключ, провайдер выбирается в интерфейсе и применяется ко всем строкам, значения сохраняются как есть;
- просмотр заказов, отчётов, пользователей и обратной связи;
- поиск по таблицам админки по любому столбцу и сортировка кликом по заголовкам;
- ручная смена статуса заказа (оплачен/ошибка);
- журнал админ-заметок (любой формат данных сохраняется как есть);
- отдельный раздел **«Системные промпты»** для добавления, изменения и удаления системных промптов; ключи выбираются из выпадающего списка PROMPT_T0–PROMPT_T3, при необходимости доступен ввод собственного ключа (при наличии промптов в админке файл `.env.prompts` игнорируется).  

Интерфейс админки построен в виде левого меню разделов и правой рабочей области, где отображается только выбранный раздел.  

> Важно: админка не предназначена для публичного доступа — обязательно используйте сложный `ADMIN_API_KEY` и ограничьте доступ по сети/фаерволу.

Дополнительно: при старте приложения ключи из `.env` автоматически синхронизируются в БД (если в БД пусто). Это позволяет сразу видеть статистику использования в разделе **«LLM ключи»** даже без ручного ввода в админке.

## Локальная отладка

### Запуск через tmux (только для локальной отладки, **не для продакшена**)

1. Установите tmux и создайте сессию:

```bash
sudo apt install tmux
tmux new -s numerolog_bot
```

2. Запустите API в первой панели:

```bash
source .venv/bin/activate
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

3. Разделите окно на две панели и запустите бота:

```bash
tmux split-window -h
source .venv/bin/activate
python -m app.bot.polling
```

4. Выйдите из tmux без остановки процессов:

```bash
tmux detach
```

5. Чтобы вернуться в сессию:

```bash
tmux attach -t numerolog_bot
```

> Для продакшена используйте **только** `systemd`, чтобы гарантировать один экземпляр процесса и автозапуск при перезагрузке сервера. Ручные запуски и `tmux` в продакшене не используйте.

## Проверки

Быстрые сценарные проверки (без внешних зависимостей по умолчанию):

```bash
./scripts/test.sh
```

Сценарии включают:
- T0 cooldown,
- оплата → генерация,
- fallback LLM,
- webhook-валидация провайдеров,
- повторная выдача PDF.

## Контентная безопасность

После генерации отчёта применяется post-фильтр: запрещённая лексика, паттерны гарантий/предсказаний и «красные зоны».  
Если обнаружены нарушения, выполняется регенерация (до 2 раз).  
Если текст по-прежнему содержит «красные зоны», бот возвращает безопасный отказ.  
Если нарушения остаются без красных зон, бот выдаёт резервный безопасный отчёт.  
Флаги фильтрации сохраняются в `reports.safety_flags`.
При необходимости можно отключить post-фильтр через `REPORT_SAFETY_ENABLED=false` (текст отправляется без проверки).  

## LLM fallback

- Основной провайдер — Gemini, fallback — OpenAI.
- При любой ошибке Gemini бот сначала перебирает оставшиеся ключи Gemini, а затем автоматически переключается на OpenAI.
- Для Gemini системные инструкции передаются через `systemInstruction`, а данные — отдельным блоком `facts-pack`, чтобы избежать ошибок валидации запроса.
- При 429 применяется увеличенный backoff (с учётом `Retry-After`, если он задан), а ключ временно блокируется в памяти (circuit breaker), чтобы снизить риск повторных rate-limit.
- Ключи из `.env` автоматически появляются в админке, поэтому статистика их использования обновляется в таблице **«LLM ключи»** без ручной загрузки.
- Если в админке добавлены LLM-ключи, они используются в приоритетном порядке и полностью заменяют ключи из `.env` (включая многострочные списки).

## Автодеплой

Подробные пошаговые инструкции по настройке автодеплоя описаны в `AUTODEPLOY_INSTRUCTIONS.md`.

## Системные промпты по тарифам

Системные промпты можно управлять через веб-админку (раздел **«Системные промпты»**).  
Промпты, сохранённые в админке, имеют приоритет: если в базе есть хотя бы один промпт, файл `.env.prompts` полностью игнорируется.  
Если в админке нет промптов, то используются значения из `.env.prompts` (переменные `PROMPT_T0`, `PROMPT_T1`, `PROMPT_T2`, `PROMPT_T3`) либо встроенные безопасные значения.  
Пример заполнения находится в `.env.prompts.example`.

## Запуск через systemd

`systemd` обеспечивает запуск **ровно одного экземпляра** сервиса (API и бота) и автоматический рестарт при сбоях.

### Пример unit-файла для API (`/etc/systemd/system/numerolog-api.service`)

```ini
[Unit]
Description=Numerolog Bot API (FastAPI)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/uvicorn app.main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Пример unit-файла для бота (`/etc/systemd/system/numerolog-bot.service`)

```ini
[Unit]
Description=Numerolog Bot (Telegram, aiogram)
After=network.target

[Service]
Type=simple
User=deployer
WorkingDirectory=/var/www/numerolog_bot
EnvironmentFile=/etc/numerolog_bot/.env
ExecStart=/var/www/numerolog_bot/.venv/bin/python -m app.bot.polling
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### Управление сервисами

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog-api.service
sudo systemctl enable --now numerolog-bot.service
```

**Стандартный способ перезапуска после деплоя (гарантирует одиночные процессы и предотвращает размножение инстансов):**

```bash
sudo systemctl restart numerolog-api.service
sudo systemctl restart numerolog-bot.service
```

### Пример target для общего управления

Если хотите управлять API и ботом одной командой, создайте target:

```ini
# /etc/systemd/system/numerolog.target
[Unit]
Description=Numerolog Bot (API + Bot)
Requires=numerolog-api.service numerolog-bot.service
After=network.target
```

Команды:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now numerolog.target
sudo systemctl restart numerolog.target
```

## Использование

- Откройте чат с ботом в Telegram и нажмите **Start** — на стартовом экране доступны кнопки **«Тарифы»**, **«Оферта»**, **«Обратная связь»** с одной иконкой перед текстом.
- После перехода на экран тарифов показываются четыре CTA-кнопки в одном столбце с соответствующими иконками: «Твоё новое начало», «В чём твоя сила?», «Где твои деньги?», «Твой путь к себе!» (глобальное меню на этом экране скрыто).
- Для T0 бот сразу запускает пошаговый ввод профиля (имя, дата, время, место рождения), а для T1–T3 мастер ввода стартует после подтверждения оплаты.
- В тарифах T2/T3 после профиля запускается лайтовая анкета из `app/bot/questionnaire/questionnaire_v1.json` с сохранением прогресса и поддержкой типов text/choice/scale; ответы принимаются в произвольном формате без форматирования и валидации.
- Управляйте сценариями через inline-клавиатуру: тарифы, оферта, обратная связь (в большинстве экранов).
- Все тексты экранов могут начинаться с технического идентификатора экрана (например, `S1:`), чтобы быстрее сверять сценарии с кодом; префикс включается через `SCREEN_TITLE_ENABLED`.
- Экран “Мои данные” работает в режиме просмотра и показывает сохранённые поля профиля.
- Если тариф ещё не выбран, кнопка “Мои данные” возвращает к выбору тарифа, чтобы соблюсти порядок экранов.
- Для платных тарифов без подтверждённой оплаты экран “Мои данные” показывает кнопку перехода к оплате и блокирует старт мастера ввода.
- На экране “Мои данные” всегда доступна кнопка “Назад” для возврата к тарифам.
- Если профиль уже заполнен, на экране “Мои данные” доступна кнопка “Удалить мои данные” — она открывает подтверждение с кнопками «Да/Отмена» и очищает все данные пользователя, сохраняя учётную запись.
- Экран оплаты открывается только после перехода через оферту (S2 → S3), чтобы зафиксировать согласие с условиями.
- Для заполнения профиля нажмите “Заполнить данные” и последовательно введите имя, дату рождения, время рождения и место рождения в любом формате.
- Если профиль уже заполнен, кнопка “Редактировать” открывает частичное редактирование по полям без потери остальных данных.
- После выбора тарифа “Т0 - Твоё новое начало (бесплатно)” показывается отдельный экран с описанием превью и
  кнопками “Старт”, “Назад” и “Обратная связь” (без пунктов “Оферта” и “Мои данные” на этом экране).
- Если лимит T0 исчерпан, экран уведомления (S9) показывает одну кнопку “Назад” и возвращает к тарифам.
- Глобальное меню (Тарифы, Мои данные, Оферта, Обратная связь) доступно на большинстве ключевых экранов
  (кроме экрана тарифов после «Далее...» и экрана превью T0).
- Для платных тарифов создаётся заказ в БД, оплата подтверждается перед генерацией отчёта.
- Для тарифа Т0 действует лимит 1 раз в месяц (настраивается через `FREE_T0_COOLDOWN_HOURS`).
- Для тарифов T2/T3 после профиля запускается анкета (конфиг `app/bot/questionnaire/questionnaire_v1.json`) и доступна только после подтверждённой оплаты; ответы принимаются в произвольном формате без форматирования и валидации.
- Прогресс анкеты сохраняется в БД и может быть продолжен с того же шага.
- После завершения анкеты доступна кнопка «Редактировать анкету», которая запускает повторный проход без сброса сохранённых ответов.
- После заполнения анкеты появляется кнопка «Редактировать данные», чтобы вернуться к экрану профиля и обновить сведения перед запуском генерации отчёта.
- Состояние экранов сохраняется в таблице `screen_states`, поэтому при рестарте процесса выбор тарифа
  и данные экранов восстанавливаются из БД; там же хранится список `user_message_ids`, чтобы удалять
  пользовательские сообщения при переходах между экранами.
- После успешной генерации отчёт сохраняется в таблице `reports`, а при повторном просмотре экрана S7 текст подтягивается из БД.
- На экране S7 доступна кнопка «Назад», возвращающая к тарифам.
- В тексте отчёта поддерживается жирное форматирование через `**...**` — маркеры преобразуются в жирный шрифт при отправке сообщения.
- После генерации отчёта выполняется фильтрация: запрещённые слова/паттерны “гарантий/предсказаний” вызывают регенерацию (до 2 попыток), при «красных зонах» выдаётся безопасный отказ, а при остальных нарушениях — резервный безопасный отчёт.
- Информация о фильтрации записывается в `reports.safety_flags`.
- При переходах между экранами бот удаляет предыдущие сообщения, пользовательские ответы и inline-клавиатуры (включая шаги анкеты и мастера профиля). Пользовательские сообщения удаляются сразу после обработки, а если Telegram не позволяет удалить сообщение — бот редактирует его в нейтральный текст без клавиатуры.
- Запросы к LLM идут в Gemini как к основному провайдеру, при любой ошибке выполняется перебор всех доступных ключей Gemini, и только после их исчерпания выполняется fallback на ChatGPT с ограниченными ретраями (до 2 на Gemini и до 1 на ChatGPT). При наличии нескольких API-ключей каждого провайдера выполняется автоматический перебор ключей до fallback.
- PDF формируется автоматически сразу после генерации отчёта и сохраняется в `reports.pdf_storage_key`. Кнопка “Выгрузить PDF” остаётся для повторных скачиваний.
- Telegram ID пользователя хранится в `users.telegram_user_id` и `screen_states.telegram_user_id` как `BIGINT`, чтобы корректно обрабатывать большие значения.
- Для каждого экрана можно подключить локальную картинку: бот ищет её в папке `SCREEN_IMAGES_DIR` и, если находит, отправляет перед текстом экрана.

## Обратная связь (экран S8)

В экране “Обратная связь” пользователь пишет текстовое сообщение и нажимает “Отправить”.
Поведение зависит от режима в `.env`:

- `FEEDBACK_MODE=native` — бот отправляет сообщение в `FEEDBACK_GROUP_CHAT_ID` через Bot API и
  сохраняет результат в `feedback_messages` со статусом `sent`/`failed`.
- `FEEDBACK_MODE=livegram` — бот не отправляет сообщение напрямую, а просит перейти в группу
  по `FEEDBACK_GROUP_URL` (fallback-сценарий). Нажатие «Отправить» фиксирует попытку
  как `failed` в `feedback_messages`, чтобы видеть неуспешные отправки.
- Если `FEEDBACK_GROUP_CHAT_ID` отсутствует в режиме `native`, бот не падает и сообщает,
  что настройка не задана; попытка также логируется со статусом `failed`.

## PDF-хранение

- По умолчанию PDF сохраняются локально в каталог `storage/pdfs` (или другой путь, заданный через `PDF_STORAGE_KEY`).
- Если указать `PDF_STORAGE_BUCKET`, файлы сохраняются в S3-совместимом бакете. `PDF_STORAGE_KEY` используется как префикс ключа.
- Для bucket-хранилища задайте переменные `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION` и при необходимости `AWS_ENDPOINT_URL`.
- Для корректной кириллицы задайте `PDF_FONT_PATH` (например, `/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf`): при генерации PDF используется этот пользовательский шрифт, а при отсутствии файла — встроенный резервный.
- PDF генерируется автоматически сразу после формирования отчёта, а повторные скачивания используют сохранённый `reports.pdf_storage_key` (если доступно хранилище). Кнопка «Выгрузить PDF» остаётся для ручной повторной выдачи.
- При переходе на следующий экран PDF-сообщение автоматически удаляется, а пользователь получает уведомление о сохранении отчёта в личном кабинете.
- Если `PDF_STORAGE_BUCKET` не задан, S3-хранилище не удалось инициализировать (например, отсутствует `boto3`) или запись в бакет завершилась ошибкой, сервис автоматически использует локальный каталог и всё равно сохраняет `reports.pdf_storage_key`.
- Имя PDF-файла формируется автоматически и содержит `@username`, тариф и время получения отчёта, чтобы файл был легко узнаваемым в истории загрузок.

## Анкета T2/T3

- Конфигурация анкеты хранится в `app/bot/questionnaire/questionnaire_v1.json`.
- Поддерживаются типы вопросов: `text`, `choice`, `scale`, обязательность и переходы по логике; ответы принимаются в произвольном формате без форматирования и валидации.
- В текущей версии анкеты все вопросы настроены как свободный ввод без обязательного формата.
- Ответы сохраняются по мере ввода и используются при формировании facts-pack для LLM.
- Webhook оплаты принимает запросы на `/webhooks/payments` и проверяет подпись провайдера.
- Если основной провайдер недоступен или не сконфигурирован, бот пробует сформировать ссылку через CloudPayments и обновляет `orders.provider` для корректной проверки статуса.
- При отсутствии параметра `provider` в webhook-URL API пытается валидировать подпись сначала основным провайдером, затем fallback-провайдером.
- Кнопка “Я оплатил(а)” запрашивает статус у платёжного провайдера и переводит на ввод данных
  только после подтверждения оплаты.
- Генерация отчётов использует LLM-маршрутизатор: Gemini (основной) с 1–2 ретраями на 5xx/timeout,
  перебором всех доступных ключей Gemini при любой ошибке и fallback на ChatGPT только после исчерпания ключей (у ChatGPT — 1 retry на transient).
  Если указаны несколько ключей для провайдера, они перебираются автоматически при ошибках/недоступности.
- Перед отправкой в LLM формируется facts-pack (JSON) с исходными полями профиля и анкеты
  без нормализации и валидации: пользовательские строки передаются как есть.
- Если недоступны оба провайдера, бот показывает экран “Сервис временно недоступен”.
- Если ключи LLM не настроены ни в `.env` (нет `GEMINI_API_KEY`/`GEMINI_API_KEYS` и `OPENAI_API_KEY`/`OPENAI_API_KEYS`),
  ни в админке (раздел «LLM ключи»), бот сразу показывает экран “Сервис временно недоступен”
  и не запускает генерацию.
- Команда `/lk` открывает экран “Личный кабинет” (S11) и показывает сохранённые данные профиля и расширенной анкеты без форматирования.
- В кабинете доступен список “Мои отчёты” с кнопками “Открыть”, “Выгрузить PDF” и “Удалить”, чтобы повторно использовать или удалить сохранённые отчёты.

## Логика тарифов и оплат

- Т0 можно запросить только после окончания cooldown: бот сверяет `last_t0_at` в таблице `free_limits`.
- Для T1–T3 бот создаёт запись в `orders` со статусом `created` и показывает экран оплаты.
- Генерация отчёта доступна **только** после статуса `paid`.
- Для платных тарифов действует правило «одна оплата — один отчёт»: если отчёт уже создан для заказа, бот показывает сохранённый результат и не запускает повторную генерацию.
- После генерации отчёта создаётся запись в `reports`; для платных тарифов отчёт связывается с оплаченной записью `orders`.
- Абстракция `PaymentProvider` отвечает за создание платёжной ссылки и проверку webhook.

## Обслуживание базы данных

- При обновлении схемы базы данных используйте `alembic upgrade head`.
- Миграция `0004_expand_telegram_user_id` расширяет тип Telegram ID до `BIGINT`, чтобы исключить ошибку `integer out of range`.

## Переменные окружения

Минимально необходимые:

- `BOT_TOKEN` — токен Telegram-бота.
- `GEMINI_API_KEY`/`GEMINI_API_KEYS`, `OPENAI_API_KEY`/`OPENAI_API_KEYS` — ключи LLM (если ключей нет и в `.env`,
  и в админке, генерация отчёта блокируется и показывается экран “Сервис временно недоступен”).
- `PRODAMUS_FORM_URL`/`CLOUDPAYMENTS_PUBLIC_ID` — ключи для формирования платёжной ссылки (при отсутствии бот сообщает, что оплата недоступна).
  Если в веб-админке заведены LLM-ключи, значения из `.env` для LLM игнорируются.

Дополнительные параметры (см. `.env.example`):

- `FEEDBACK_GROUP_CHAT_ID`, `FEEDBACK_GROUP_URL`, `FEEDBACK_MODE`
- `LLM_PRIMARY`, `LLM_FALLBACK`, `LLM_TIMEOUT_SECONDS`
- `REPORT_SAFETY_ENABLED` (включает/отключает post-фильтрацию отчёта)
- `SCREEN_TITLE_ENABLED` (включает/отключает показ технического идентификатора экрана в тексте)
- `SCREEN_IMAGES_DIR` (путь к локальному хранилищу изображений экранов)
- `GEMINI_API_KEY`, `GEMINI_API_KEYS`, `GEMINI_MODEL`, `GEMINI_IMAGE_MODEL`
- `OPENAI_API_KEY`, `OPENAI_API_KEYS`, `OPENAI_MODEL`
- `PAYMENT_PROVIDER`, `PRODAMUS_FORM_URL`, `PRODAMUS_SECRET`, `PRODAMUS_WEBHOOK_SECRET`,
  `PRODAMUS_STATUS_URL`, `CLOUDPAYMENTS_PUBLIC_ID`, `CLOUDPAYMENTS_API_SECRET`,
  `PAYMENT_WEBHOOK_URL`
- `FREE_T0_COOLDOWN_HOURS`
- `DATABASE_URL`, `PDF_STORAGE_BUCKET`, `PDF_STORAGE_KEY`
- `PDF_FONT_PATH` (путь к TTF-шрифту для PDF, например DejaVuSans)
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_DEFAULT_REGION`, `AWS_ENDPOINT_URL` (если используете bucket)
- `ENV`, `LOG_LEVEL`
- `MONITORING_WEBHOOK_URL` (вебхук мониторинга для события `report_generate_failed`)

## Автодеплой

Пошаговые инструкции по автодеплою через GitHub Actions находятся в
[`AUTODEPLOY_INSTRUCTIONS.md`](AUTODEPLOY_INSTRUCTIONS.md).

Ключевые секреты для workflow:
- `SERVICE_NAME` — имя systemd-сервиса или target для перезапуска.
- `SERVICE_NAMES` — опционально, список сервисов/target’ов через пробел (имеет приоритет).
- `ENV_FILE`, `DEPLOY_PATH`, `SSH_HOST`, `SSH_USER`, `SSH_PORT`, `SSH_PRIVATE_KEY` — инфраструктурные параметры.

Workflow запускает `scripts/deploy.sh` на сервере и передаёт ссылку на ветку,
в которую был сделан push (например, `origin/work` или `origin/main`).
По умолчанию workflow настроен на ветки `main` и `work` — убедитесь, что ваш push выполняется
в одну из них или расширьте список веток в `.github/workflows/deploy.yml`.
Проверьте, что unit-файлы созданы и имена сервисов совпадают с тем, что вы передали
в `SERVICE_NAME`/`SERVICE_NAMES`. Если получаете ошибку вида
`...service: command not found`, это признак отсутствующего unit-файла или неверного имени сервиса.
.

## Экранные изображения

Бот отображает картинку для каждого экрана, если она есть в локальном хранилище.
Папка задаётся через `SCREEN_IMAGES_DIR` (по умолчанию `app/assets/screen_images`). Внутри должны быть
каталоги с именами экранов:

- Статичные экраны: `S0`, `S1`, `S8`, `S9`, `S10`, `S11`, `S12`.
- Тариф-зависимые экраны: `S2_T0`, `S2_T1`, `S2_T2`, `S2_T3` (аналогично для `S3`, `S4`, `S5`, `S6`, `S7`).
- Экраны просмотра/удаления отчёта: `S13_T0`...`S13_T3`, `S14_T0`...`S14_T3`.

В каждом каталоге достаточно разместить **любой один файл изображения** (формат и имя не важны).
Дополнительно в каждом каталоге размещён файл `description.txt` с кратким описанием экрана и условия его показа.
Если файл отсутствует — экран продолжит работать без картинки.
Для автоматической генерации картинок используйте команду `/fill_screen_images`: она запросит универсальный промпт,
затем через Gemini с моделью `GEMINI_IMAGE_MODEL` создаст изображения для каждого каталога и сохранит их локально.
Если Gemini вернёт 429, генерация остановится и подскажет, когда повторить попытку.
